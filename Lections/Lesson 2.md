В прошлый раз рассмотрели ввод/вывод для MPI

# Произведение матриц
Так как матрица хранится по частям в разных процессах, то произведение матрицы и векторного столбца нетривиально.
Первый шаг: умножение внутри каждого процесса на соответствующие столбцы
![[IMG_9456.jpg]]
Второй шаг: каждый процесс отправляет остальным свой столбец, процессы принимают, и перемножают у себя
![[IMG_9457.jpg]]

Пропишем реализацию умножения матрицы на вектор:
```cpp
void matrix_mult_vector(
	double *a,
	double *b,
	double *c,
	int n,
	int k,
	int p,
	MPI_Comm com
) {
	// число строк в процессе
	int rows = get_rows(n, m, p, k); // в предыдущей лекции писали
	// макс колво блочных строк в процессах
	int max_rows = get_max_rows(n, m, p);
	// число блочных строк
	int max_bl = (n + m - 1) / m, bl;
	int src = (k + 1) % p;
	int dst = (k - 1 + p) % p;
	memset(c, 0, rows * sizeof(double));
	for (int l = 0; l < p; l++) {
		// Чьи данные находятся в b ?
		// В нач момент l = 0 - это мои данные
		int lk = (k + l) % p;
		// Сколько строк в b ?
		int lk_rows = get_rows(n, m, p, lk);
		for (int lk_i = 0; lk_i < lk_rows; lk_i ++) {
			// Здесь должно быть умножение блоков
			// Делаем для неблочного вида (?)
			for (i = 0; i < rows; i++) {
				// c_i += A_{i, lk_i} * b_{lk_i}
				int lk_m = lk_i * m + m <= n ? m : n - lk_i * m; // число строк
				int i_m = i * m + m <= n ? m : n - i * m;
				// блок A_{i,lk_i} имеет размер i_m * lk_m
				for (int ii = 0; ii < i_m; ii++) {
					doble s = 0; // накопительная сумма
					for (int jj = 0l j < lk_m; jj++) {
						s += a[i*n*m + ii*n + lk_i*m + jj] * b[lk_i*m + jj];
					}
					c[i*m + ii] += s;
				}
			}
		}
		// Обмен
		MPI_Status st;
		MPI_Sendrecv_replace(
			b,
			max_rows*m,
			MPI_DOUBLE,
			dst,
			0, /*tag*/
			src,
			0, //tag
			com,
			&st	
		)
	}
}
```

# Приближение функций, аппроксимация, итерационные методы решения систем
Будет рассмотрено несколько применений этой задачи. 
На абстрактной области построена функция f. Нужно построить приближение функции Lf, такая что $||Lf - f||_{L2(Ω)}$ -> min
Мы пока не можем работать с произвольной областью. Ставится задача триангуляции, которая говорит о том, что мы можем область представить в виде объединения треугольников, задана h = max diam (triangles). При h -> 0, $N_h$ -> $\infty$ 
Треугольники либо пересекаются по вершине, ребру или пустому множеству. При такой триангуляции. То есть симметрическая разность области и её триангуляции непуста. $mes(Ω\Ω_h) + mes(Ω_h\Ω) = O(h^2)$, если же рассматривать аппроксимацию области квадратами, то будет O(h). Нужно дополнительное условие квазиравномерности: 
$$
r_i - радиус вписаной окр \\
R_i - радиус описанной окр \\
a_1 = min(r_i/R_i) \\
a_2 = max(r_i/R_i) \\
Существует lim a_1, lim a_2, i -> \infinity
$$

### Триангуляции для известных областей:
1) Прямоугольник
2) Параллелограмм
3) Полярные
4) Треугольник
5) Трапеция
![[IMG_9460.jpg]]

### Разбиение областей с известными триангуляциями

![[IMG_9462.jpg]]
### Для произвольных областей

1) строим объемлющий прямоугольник
2) Берём аппроксимацию с недостатком/избытком 
С недостатком: только если все 4 вершины попали в область
С избытком: если хоть 1 вершина попала
![[IMG_9463.jpg]]

[[Lesson 2]]### Для произвольных 2
Деформируем сетку вдоль горизонтальных/вертикальных линий вдоль границы области
![[IMG_9464.jpg]]

### Для произвольных 3
границу делим на одинаковые части и идём к центру
![[IMG_9466.jpg]]

### Трёхмерная область
Для трёхмерной области всё в разы сложнее, существует не для всех (?)

### Продолжение
Считаем, что область триангулировали. На нашей области вводятся обозначения
Ω_h - триангуляция
P_j - вершины триангуляции
tr_i - iй треугольник
tr_i ^ tr_j = ребро, вершина или пустое мношество
Вводим функцию $phi_j = 0 в точке Pj, 0 в остальных точках, линейна на tr_i, содержащих эту вершину$
![[IMG_9468.jpg]]
phi - функция Куранта
![[IMG_9469.jpg]]
L(Ω_h) = {пространство линейных непрерывных на каждом треугольнике}
Phi \in L(Ω_h) <=> (c1, ... cn)
cj - значение phi в Pj
![[IMG_9472.jpg]]
$\{ \phi_j \}_{j=1}^n$ - базис
$\phi(x) = \sum_{i=1}^n phi(P_i) \times \phi_i(x)$

![[IMG_9474.jpg]]
![[IMG_9475.jpg]]
![[IMG_9478.jpg]]

Разобьём прямоугольник
Если хотим точность 10^{-6} точность, то h=1000
Однако нужно хранить 10^12 элементов, это уже терабайты.
![[IMG_9479.jpg]]
Что же делать и как применить базис?
Из-за нашего строения матрицы очень мало элементов, не равных нулю. И хранить надо вместо n^2 всего ~7 * n элементов
![[IMG_9482.jpg]]
![[IMG_9483.jpg]]
Наши задачи:
1) Хранение
2) Ax=b
Нужно найти альтернативные способы решения разреженных матриц!