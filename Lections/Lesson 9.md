Нужен +1 поток для рисования UI. Он принимает сообщения в очередь сообщений. Когда очередь заполняется, приходит уведомление, что приложение не отвечает.

Пусть есть старый ответ, который хранится в GUI потоке. В других потоках считается новый ответ для удвоенного количества точек. Должен быть протокол обмена информацией, чтобы GUI поток мог общаться с другими процессами.

Есть 2 класса с данными для передачи сообщения. Память выделяет ГУИ или Вычислительный процесс. Один локальный в Гуи потоке, второй - разделяемый экземпляр для ГУИ и ВЫЧ потоков. 1 - показывает, 2 - для нового запроса.

Варианты отправки событий:
1) Послать события в очередь событий
2) Таймер
Делает lock, проверяет состояние, и если есть обновлённые данные, то удаляет старые данные, записывает новые, потом очищает 2ю структуру под новый запрос

Если в ГУИ потоке нажали крестик, то 2 варианта:
1) Если потоки не считают, то выход
2) Если считают, то нужно дождаться

Разберёмся подробнее, что делает графический поток.
Пусть есть функция 2х переменных и нужно нарисовать поверхность в 3Д. Нужно рисовать ОЧПОЧМАКИ. Делаем фиксированную размерность, которую программа получает в качестве аргумента и строим сетку этой размерности, соединяя узлы в треугольники.

Есть массивы точек `points`, есть массив треугольников `triangles`
Вводится положение наблюдателя.
Определяется способ сравнения треугольников - метрика до наблюдателя. По этой метрике массив треугольников сортируют.
Рисуем, начиная от дальнего.
Как нарисовать один треугольник в пространстве?
Нужно делать проекцию на плоскость наблюдателя. Бывают ксонометрические проекции и другие. Можно применять матрицу вращения.

Второй вариант показа: 3я координата переходит в цвет!
Считается $z_{min}, z_{max}$ для нахождения ошибки $\max{(z_{min}, z_{max})}$, и эти же значения можем использовать для отображения в цвет! 
$$
[z_{min}, z_{max}] \rightarrow [0,1]
$$
Вводим RGB, они измеряются от 0 до 255