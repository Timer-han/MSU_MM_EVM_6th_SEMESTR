Хранение будет осуществляться с помощью матрицы смежности:
$(i, j, a_{ij} != 0)$
И таких элементов $7 * n^2$
A ~ NxN
$S(A) = {(i, j): a_{ij}}$
|S(A)| объём хранения
$S(A) + \{A_{ij}\}_{i, j \in S(A)}$
Для симметричной матрицы можно хранить в 2 раза меньше данных. Таких случаев очень много, т.к. большинство явлений в природе обратимы.
Способы хранения:
0) $(i, j, a_{ij}) for all (i, j) \in S(A)$
	M * 2 * sizeof(int) + M * sizeof(double) == 2 * sizeof(double) 
	Плохой способ. Попробуем упорядочить
1) Если вначале хранить только элементы первой строки, потом второй и тд. Тогда нужно будет хранить только номер столбца + индексный массив, который указывает на начала новых сторок матрицы смежности. Разность 2х соседних элементов - длина $i$-й строки. 
	$A[k], A[k+1],  \cdots, A[k + l - 1]$ 
	___Compressed Sparce Row Format (CSR)___
	Объём: m\*sizeof(double) + M\*sizeof(int) + (N+1) \* sizeof(double\*)
	![[IMG_9491.jpg]]
2) Если знаем, что a_{ii} != 0, то можно не хранить часть информации
	$A[i] = a_{ii}, i=0\cdots N-1$
	I[i] - Индекс начала $i$-й строки
	$l = I[i + 1] - I[i]$ -число элементов $i$-й строки
	$A[I[i] + j], j=0 \cdots l-1$ элемент i-й строки
	$I[I[i] + j]$ - номера j $a_{ij}$ элементы != 0
	(M + 1) \* sizeof(double) + (M + 1) \* sizeof(int)
	___Modified Sparse Row Format___

Удастся ли ли посчитать произведение матрицы на вектор?
```cpp
void mult_msr_matrix_vector (
	double *A,
	int *I,
	int n,
	double *x,
	double *y
) {
	int i, j, l, ;
	double s;
	for (i = 0; i < n; i++) {
		// диагональный элемент
		s = A[i] * x[i]; // A_ii * x_i
		// число != 0 вне диагональных элементов
		l = I[i+1] -I[i];
		// начало строки i
		J = I[i];
		for ( j = 0; j < l; j++) {
			s += A[J + j] * x[I[J + j]]; // I[J+j] - номер столбца для A[j+j]
		}
		y[i] = s;
	}
}
```
Сложность стала всего $n * M = n * S(A) \sim n * 7$
Но это же ужас! Поэтому напишем параллельную версию:
```cpp
void mult_msr_matrix_vector (
	double *A,
	int *I,
	int n,
	double *x,
	double *y,
	int p, // число потоков
	int a
) {
	int i, j, l, J;
	int i1, i2;
	double s;
	i1 = n * k; i1 /= p;
	i2 = n * (k + 1); i2 /= p;
	for (i = i1; i < i2; i++) {
		// диагональный элемент
		s = A[i] * x[i]; // A_ii * x_i
		// число != 0 вне диагональных элементов
		l = I[i+1] - I[i];
		// начало строки i
		J = I[i];
		for (j = 0; j < l; j++) {
			s += A[J + j] * x[I[J + j]]; // I[J+j] - номер столбца для A[j+j]
		}
		y[i] = s;
	}
	reduce_sum(p);
}
```
 Насколько же это быстро работает? Рассмотрим работу со "своими" и "чужими" элементами". Есть небольшой конфликт по чтению. Если $j \in [i1, i2)$, то это свои элементы. А если $I[J + j] \notin [i1, i2]$, то обращение $x[I[J + j]]$ будет к чужим элементам. Для MPI версии это очень плохо, поэтому вспомним, что наша матрица симметрична, и может оказаться так, что в k-м процессе уже может лежать нужный элемент, который можем использовать для умножения, это вычисляется.
 
![[IMG_9495.jpg]]

![[IMG_9494.jpg]]

$$i_1^k \cdots i_{r-1}^k$$
$$[i_1^k, \cdots, i_{r}^k]$$
$$S^k(A) = \{(i, j) : i \in [i_1^k, \cdots, i_r^k), a_{ij} \neq 0\}$$
$$M = |S^k(A)|$$
Отдельно храним номера строк
![[IMG_9496.jpg]]
![[IMG_9499.jpg]]

Если мы хотим решать Ax = b, то Гаусс поможет не всегда.
Можем строить последовательность векторов, которы мб сойдутся к решению